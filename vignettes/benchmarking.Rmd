---
title: "Parallel processing and performance benchmarking"
author: "David Wachsmuth"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{benchmarking}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(matchr)
```

The functions in matchr can be very computation- and time-intensive. While they can be used "out of the box" with no considerations for optimizing performance on small or medium-sized datasets, processing large sets of images will potentially be frustratingly slow without some care to leveraging multicore processors and to memory requirements.

## Parallel processing 

All of the time-consuming functions in matchr support parallel and remote processing via the [future](https://cran.r-project.org/web/packages/future/vignettes/future-1-overview.html) package. If a multisession, multicore, or cluster plan is set through future, matchr functions will generally perform substantially faster. Some benchmarks follow.

### load_image

The following calculations show timing for reading vectors of 100, 1000 and 10,000 file paths with load_image. The paths_low vector contains low-resolution images (roughly 200 x 150 pixels, and 8 kB), while the paths_high vector contains higher-resolution images (between 640 x 480 and 1200 x 800, and 170 kB). Because the memory requirements of importing the higher-resolution images are so high, only 1000 images are read in that case. Multisession benchmarks are run separately then merged with the rest to avoid including the one-time overhead involved in initializing multisession futures in the results.

```{r import-benchmark, eval = FALSE}

library(future)

paths_low <- list.files("/Volumes/Data 2/Scrape photos/vancouver/kj", full.names = TRUE)
paths_low <- paths_low[1:10000]

paths_high <- list.files("/Volumes/Data 2/Scrape photos/vancouver/ab", full.names = TRUE)
paths_high <- paths_high[1:10000]

library(future)
library(microbenchmark)

# Benchmark sequential plan
plan(sequential)

li_seq <-
  microbenchmark(seq_1_low_100 = load_image(paths_low[1:100], quiet = TRUE),
                 seq_1_low_1k = load_image(paths_low[1:1000], quiet = TRUE),
                 seq_1_low_10k = load_image(paths_low, quiet = TRUE),
                 seq_1_high_100 = load_image(paths_high[1:100], quiet = TRUE),
                 seq_1_high_1k = load_image(paths_high[1:1000], quiet = TRUE),
                 times = 5)

qs::qsave(li_seq, "li_seq.qs")

# Benchmark multisession plan
plan(multisession, workers = 4)

li_ms_4 <-
  microbenchmark(ms_4_low_100 = load_image(paths_low[1:100], quiet = TRUE),
                 ms_4_low_1k = load_image(paths_low[1:1000], quiet = TRUE),
                 ms_4_low_10k = load_image(paths_low, quiet = TRUE),
                 ms_4_high_100 = load_image(paths_high[1:100], quiet = TRUE),
                 ms_4_high_1k = load_image(paths_high[1:1000], quiet = TRUE),
                 times = 5)

qs::qsave(li_ms_4, "li_ms_4.qs")

plan(multisession, workers = 10)

li_ms_10 <-
  microbenchmark(ms_10_low_100 = load_image(paths_low[1:100], quiet = TRUE),
                 ms_10_low_1k = load_image(paths_low[1:1000], quiet = TRUE),
                 ms_10_low_10k = load_image(paths_low, quiet = TRUE),
                 ms_10_high_100 = load_image(paths_high[1:100], quiet = TRUE),
                 ms_10_high_1k = load_image(paths_high[1:1000], quiet = TRUE),
                 times = 5)

qs::qsave(li_ms_10, "li_ms_10.qs")

plan(multisession, workers = 32)

li_ms_32 <-
  microbenchmark(ms_32_low_100 = load_image(paths_low[1:100], quiet = TRUE),
                 ms_32_low_1k = load_image(paths_low[1:1000], quiet = TRUE),
                 ms_32_low_10k = load_image(paths_low, quiet = TRUE),
                 ms_32_high_100 = load_image(paths_high[1:100], quiet = TRUE),
                 ms_32_high_1k = load_image(paths_high[1:1000], quiet = TRUE),
                 times = 5)

qs::qsave(li_ms_32, "li_ms_32.qs")

# Benchmark multicore plan
plan(multicore, workers = 4)

li_mc_4 <-
  microbenchmark(mc_4_low_100 = load_image(paths_low[1:100], quiet = TRUE),
                 mc_4_low_1k = load_image(paths_low[1:1000], quiet = TRUE),
                 mc_4_low_10k = load_image(paths_low, quiet = TRUE),
                 mc_4_high_100 = load_image(paths_high[1:100], quiet = TRUE),
                 mc_4_high_1k = load_image(paths_high[1:1000], quiet = TRUE),
                 times = 5)

plan(multicore, workers = 10)

li_mc_10 <-
  microbenchmark(mc_10_low_100 = load_image(paths_low[1:100], quiet = TRUE),
                 mc_10_low_1k = load_image(paths_low[1:1000], quiet = TRUE),
                 mc_10_low_10k = load_image(paths_low, quiet = TRUE),
                 mc_10_high_100 = load_image(paths_high[1:100], quiet = TRUE),
                 mc_10_high_1k = load_image(paths_high[1:1000], quiet = TRUE),
                 times = 5)

plan(multicore, workers = 32)

li_mc_32 <-
  microbenchmark(mc_32_low_100 = load_image(paths_low[1:100], quiet = TRUE),
                 mc_32_low_1k = load_image(paths_low[1:1000], quiet = TRUE),
                 mc_32_low_10k = load_image(paths_low, quiet = TRUE),
                 mc_32_high_100 = load_image(paths_high[1:100], quiet = TRUE),
                 mc_32_high_1k = load_image(paths_high[1:1000], quiet = TRUE),
                 times = 5)


```


## Memory requirements
